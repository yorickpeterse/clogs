import clogs.changelog (Changelog, Release)
import clogs.config (CONFIG_FILE, Config)
import clogs.git (Repository)
import clogs.version (Version)
import std.env (arguments, working_directory)
import std.fs.path (Path)
import std.optparse (Options)
import std.stdio (Stderr, Stdout)
import std.sys (exit)
import std.time (DateTime)

let VERSION = '0.9.0'

fn pub run(
  arguments: Array[String],
  working_directory: ref Path,
) -> Result[Nil, String] {
  let output = Stdout.new
  let opts = Options.new('clogs')

  opts.usage = '[OPTIONS] [VERSION | COMMAND]'
  opts.description = 'Examples
  clogs 1.2.3                      # Generate a changelog for version 1.2.3
  clogs --config foo.json 1.2.3    # Use a custom configuration file'

  opts.flag('h', 'help', 'Show this help message')
  opts.flag('v', 'version', 'Show the version')
  opts.single('c', 'config', 'CONFIG', 'Use the specified configuration file')
  opts.single('e', 'end', 'REF', 'The end of the commit range (default: HEAD)')

  let matches = match opts.parse(arguments) {
    case Ok(v) -> v
    case Error(e) -> throw e.to_string
  }

  if matches.contains?('help') {
    let _ = output.write(opts.to_string)

    return Result.Ok(nil)
  }

  if matches.contains?('version') {
    output.print('clogs ${VERSION}').get
    return Result.Ok(nil)
  }

  let config_path = matches.value('config').map(fn (v) { v.to_path }).or_else(
    fn { working_directory.join(CONFIG_FILE) },
  )

  match matches.remaining.get(0) {
    case Ok('init') if config_path.file? -> {
      Result.Error("the configuration file '${config_path}' already exists")
    }
    case Ok('init') -> {
      Config.default.save(config_path).map_error(fn (e) {
        'failed to generate the configuration file: ${e}'
      })
    }
    case Ok(val) -> {
      match Version.parse(val) {
        case Some(version) -> {
          update(config_path, version, matches.value('end').or('HEAD'))
        }
        case _ -> Result.Error('a version in the format X.Y.Z is required')
      }
    }
    case _ -> {
      let _ = output.write(opts.to_string)

      Result.Ok(nil)
    }
  }
}

fn update(
  config_path: Path,
  version: Version,
  end: String,
) -> Result[Nil, String] {
  let config = match Config.load(config_path) {
    case Ok(v) -> v
    case Error(e) -> throw 'failed to read ${config_path}: ${e}'
  }

  let config_dir = config_path.directory
  let repo = Repository.new(config_dir)
  let versions = match repo.versions {
    case Ok(iter) -> iter.to_array
    case Error(e) -> throw 'failed to get the Git tags: ${e}'
  }

  if !versions.contains?(version) { versions.push(version.clone) }

  versions.sort

  # At this point it's guaranteed our version is in the Array, so it's safe to
  # get the index.
  let index = versions.index_of(version).get
  let prev_version = versions.get(index - 1).map(fn (v) { v.clone }).ok
  let start = match ref prev_version {
    case Some(ver) -> ver.tag_name
    case _ -> {
      match repo.first_commit {
        case Ok(v) -> v
        case Error(e) -> throw 'failed to get the first commit: ${e}'
      }
    }
  }

  let commits = try repo.changelog_commits(start, end).map_error(fn (e) {
    'failed to get the changelog commits: ${e}'
  })

  let reverts = try repo.reverted_commits(start, end).map_error(fn (e) {
    'failed to get the list of reverted commits: ${e}'
  })

  let release = Release.new(config, version, prev_version, date: DateTime.utc)

  for c in commits.select(fn (c) { !reverts.contains?(c.id) }) {
    release.add(c)
  }

  let out_path = config_dir.join(config.changelog)
  let changelog = try Changelog.load(out_path).map_error(fn (e) {
    'failed to read ${out_path}: ${e}'
  })

  changelog.add(release)
  changelog.save.map_error(fn (e) { 'failed to update ${out_path}: ${e}' })
}

type async Main {
  fn async main {
    let pwd = working_directory.or_else(fn (_) { '.'.to_path })

    match run(arguments, pwd) {
      case Ok(_) -> {}
      case Error(e) -> {
        let err = Stderr.new
        let colors = err.terminal?
        let _ = err.print(
          if colors { '\e[31;1merror\e[0m: ${e}' } else { 'error: ${e}' },
        )

        exit(1)
      }
    }
  }
}
