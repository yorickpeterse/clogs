import clogs.changelog.(Changelog, Release)
import clogs.config.(CONFIG_FILE, Config)
import clogs.git.(Commit, Repository)
import clogs.patches
import clogs.version.Version
import optparse.(Help, Options)
import std.fs.file.(ReadOnlyFile, WriteOnlyFile)
import std.fs.path.Path
import std.io.Write
import std.set.Set
import std.string.StringBuffer
import std.sys.(exit)
import std.time.DateTime

let VERSION = '0.1.0'

fn show_help(options: ref Options, output: mut Write) {
  let help = Help
    .new('clogs')
    .usage('[OPTIONS] [VERSION | COMMAND]')
    .section('Examples')
    .line(
      'clogs 1.2.3                      Generate a changelog for version 1.2.3'
    )
    .line(
      'clogs 1.2.3 --config foo.json    Use a custom configuration file'
    )
    .line(
      'clogs init                       Generate a new configuration file'
    )
    .section('Options')
    .options(options)
    .to_string

  output.write_string(help).unwrap
}

fn pub run(
  arguments: Array[String],
  working_directory: ref Path,
  output: mut Write,
) -> Result[Nil, String] {
  let opts = Options.new

  opts.flag('h', 'help', 'Show this help message')
  opts.flag('v', 'version', 'Show the version')
  opts.single('c', 'config', 'CONFIG', 'Use the specified configuration file')
  opts.single('e', 'end', 'REF', 'The end of the commit range (default: HEAD)')

  let matches = match opts.parse(arguments) {
    case Ok(v) -> v
    case Error(e) -> throw e.to_string
  }

  if matches.contains?('help') {
    show_help(opts, output)
    return Result.Ok(nil)
  }

  if matches.contains?('version') {
    output.print("clogs {VERSION}").unwrap
    return Result.Ok(nil)
  }

  let config_path =
    matches.value('config').unwrap_or_else fn { CONFIG_FILE }.to_path

  let config_dir = config_path.directory

  # TODO: split into methods
  let version = match matches.remaining.opt(0) {
    case Some('init') -> {
      # TODO: generate empty changelog if none exists
      Config.default.save(config_path)
      return Result.Ok(nil)
    }
    case Some(v) -> match Version.parse(v) {
      case Some(v) -> v
      case _ -> throw 'a version in the format X.Y.Z is required'
    }
    case _ -> {
      show_help(opts, output)
      return Result.Ok(nil)
    }
  }

  let config = match Config.load(config_path) {
    case Ok(v) -> v
    case Error(e) -> throw "failed to read {config_path}: {e}"
  }

  let repo = match Repository.new(config_dir.clone) {
    case Some(v) -> v
    case _ -> throw "{config_dir} isn't a Git repository"
  }

  let versions = match repo.tag_names {
    case Ok(iter) -> iter.select_map fn (n) { Version.from_tag(n) }.to_array
    case Error(e) -> throw "failed to get the Git tags: {e}"
  }

  # If the version is already released, then pushing it into the list produces
  # duplicate values. This in turn may result in an inconsistent index being
  # produced (e.g. the index of the same version). Since this is incorrect, and
  # based on the premise that an existing tag means a changelog is already
  # present, we bail out if the version is already present.
  if versions.contains?(version) {
    throw "version {version} is already released"
  }

  versions.push(version.clone)
  versions.sort

  let index = versions.index_of(version).unwrap

  # BUG: https://github.com/inko-lang/inko/issues/639
  let prev_version = match versions.opt(index - 1) {
    case Some(v) -> Option.Some(v.clone)
    case _ -> Option.None
  }

  let start = match ref prev_version {
    case Some(ver) -> ver.tag_name
    case _ -> match repo.first_commit {
      case Ok(v) -> v
      case Error(e) -> throw "failed to get the first commit: {e}"
    }
  }

  let end = matches.value('end').unwrap_or('HEAD')
  let reverts = Set.new
  let commits = match repo.changelog_commits(start, end) {
    case Ok(v) -> v
    case Error(e) -> throw "failed to get the changelog commits: {e}"
  }

  match repo.reverted_commits(start, end) {
    case Ok(v) -> v.each fn (id) { reverts.insert(id) }
    case Error(e) -> throw "failed to get the list of reverted commits: {e}"
  }

  let release = Release.new(config, version, prev_version, date: DateTime.utc)

  commits.select fn (c) { reverts.contains?(c.id).false? }.each fn (c) {
    release.add(c)
  }

  let out_path = config_dir.join(config.changelog)
  let changelog = try Changelog
    .load(out_path.clone)
    .map_error fn (e) { "failed to read {out_path}: {e}" }

  changelog.add(release)
  changelog.save.map_error fn (e) { "failed to update {out_path}: {e}" }
}
