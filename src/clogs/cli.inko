import clogs.config.(CONFIG_FILE, Config)
import clogs.git.(Commit, Repository)
import clogs.patches
import clogs.version.Version
import optparse.(Help, Options)
import std.fs.path.Path
import std.fs.file.(ReadOnlyFile, WriteOnlyFile)
import std.io.Write
import std.set.Set
import std.string.StringBuffer
import std.sys.(exit)
import std.time.DateTime

let VERSION = '0.1.0'

# The placeholder to replace with the new changelog section.
#
# TODO: move elsewhere
let PLACEHOLDER = '<!-- new section -->'

# TODO: move elsewhere
fn format_date(date: DateTime) -> String {
  "{date.year}-{date.month.to_string.pad_start('0', chars: 2)}\
    -{date.day.to_string.pad_start('0', chars: 2)}"
}

fn show_help(options: ref Options, output: mut Write) {
  let help = Help
    .new('clogs')
    .usage('[OPTIONS] [VERSION | COMMAND]')
    .section('Examples')
    .line(
      'clogs 1.2.3                      Generate a changelog for version 1.2.3'
    )
    .line(
      'clogs 1.2.3 --config foo.json    Use a custom configuration file'
    )
    .line(
      'clogs init                       Generate a new configuration file'
    )
    .section('Options')
    .options(options)
    .to_string

  output.write_string(help).unwrap
}

fn pub run(
  arguments: Array[String],
  working_directory: ref Path,
  output: mut Write,
) -> Result[Nil, String] {
  let opts = Options.new

  opts.flag('h', 'help', 'Show this help message')
  opts.flag('v', 'version', 'Show the version')
  opts.single('c', 'config', 'CONFIG', 'Use the specified configuration file')
  opts.single('e', 'end', 'REF', 'The end of the commit range (default: HEAD)')

  let matches = match opts.parse(arguments) {
    case Ok(v) -> v
    case Error(e) -> throw e.to_string
  }

  if matches.contains?('help') {
    show_help(opts, output)
    return Result.Ok(nil)
  }

  if matches.contains?('version') {
    output.print("clogs {VERSION}").unwrap
    return Result.Ok(nil)
  }

  # TODO: move elsewhere
  let mut config_path = matches
    .value('config')
    .map fn (s) { s.to_path }
    .unwrap_or_else fn { CONFIG_FILE.to_path }

  config_path = config_path.expand.unwrap_or(config_path)

  let mut config_dir = config_path.directory

  config_dir = config_dir.expand.unwrap_or(config_dir)

  # TODO: split into methods
  let version = match matches.remaining.opt(0) {
    case Some('init') -> {
      # TODO: generate empty changelog if none exists
      Config.default.save(config_path)
      return Result.Ok(nil)
    }
    case Some(v) -> match Version.parse(v) {
      case Some(v) -> v
      case _ -> throw 'a version in the format X.Y.Z is required'
    }
    case _ -> {
      show_help(opts, output)
      return Result.Ok(nil)
    }
  }

  let config = match Config.load(config_path) {
    case Ok(v) -> v
    case Error(e) -> throw "failed to read the configuratin file {config_path}: {e}"
  }

  let repo = match Repository.new(config_dir.clone) {
    case Some(v) -> v
    case _ -> throw "the current working directory isn't a Git repository"
  }

  let versions = match repo.tag_names {
    case Ok(iter) -> iter.select_map fn (n) { Version.from_tag(n) }.to_array
    case Error(e) -> throw "failed to get the Git tags: {e}"
  }

  # If the version is already released, then pushing it into the list produces
  # duplicate values. This in turn may result in an inconsistent index being
  # produced (e.g. the index of the same version). Since this is incorrect, and
  # based on the premise that an existing tag means a changelog is already
  # present, we bail out if the version is already present.
  if versions.contains?(version) {
    throw "version {version} is already released"
  }

  versions.push(version.clone)
  versions.sort

  let index = versions.index_of(version).unwrap
  let start = match versions.opt(index - 1) {
    case Some(ver) -> ver.tag_name
    case _ -> match repo.first_commit {
      case Ok(v) -> v
      case Error(e) -> throw "failed to get the first commit: {e}"
    }
  }

  let end = matches.value('end').unwrap_or('HEAD')
  let reverts = Set.new
  let commits = match repo.changelog_commits(start, end) {
    case Ok(v) -> v
    case Error(e) -> throw "failed to get the changelog commits: {e}"
  }

  match repo.reverted_commits(start, end) {
    case Ok(v) -> v.each fn (id) { reverts.insert(id) }
    case Error(e) -> throw "failed to get the list of reverted commits: {e}"
  }

  # TODO: move into generator type?

  # BUG: due to https://github.com/inko-lang/inko/issues/636, an explicit type
  # signature is needed here.
  let grouped: Map[String, Array[Commit]] = Map.new

  commits.select fn (c) { reverts.contains?(c.id).false? }.each fn (commit) {
    match grouped.opt_mut(commit.category) {
      case Some(v) -> v.push(commit)
      case None -> grouped.set(commit.category, [commit])
    }
  }

  let markdown = StringBuffer.from_array([
    '<!-- new section -->',
    "\n\n"
    "## {version} ({format_date(DateTime.utc)})",
  ])

  config.categories.iter.each fn (pair) {
    let commits = match grouped.opt(pair.key) {
      case Some(v) if v.size > 0 -> v
      case _ -> return
    }

    markdown.push("\n\n### {pair.value}\n")

    commits.iter.each fn (c) {
      let url = config.url.replace('%s', c.id)
      let short = c.id.slice(start: 0, size: 7)

      markdown.push("\n* [{short}]({url}): {c.subject}")
    }
  }

  let out_path = config_dir.join(config.changelog)
  let old_data = try ReadOnlyFile
    .new(out_path.clone)
    .then fn (f) {
      let buf = ByteArray.new

      try f.read_all(buf)
      Result.Ok(buf.into_string)
    }
    .map_error fn (e) { "failed to read {out_path}: {e}" }

  let new_data = old_data.replace(PLACEHOLDER, markdown.into_string)

  try WriteOnlyFile
    .new(out_path.clone)
    .then fn (f) { f.write_string(new_data) }
    .map_error fn (e) { "failed to update {out_path}: {e}" }

  Result.Ok(nil)
}
