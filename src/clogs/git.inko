# Types and methods for working with Git repositories.
import std.fs.path.Path
import std.io
import std.iter
import std.string.ToString
import std.sys.(Command, Stream)

class Error {
  let @command: String
  let @message: String

  fn static new(command: String, message: String) -> Error {
    Error { @command = command, @message = message }
  }
}

impl ToString for Error {
  fn pub to_string -> String {
    "'git {@command}' failed: {@message}"
  }
}

class Repository {
  let @path: Path

  fn static new(path: Path) -> Option[Repository] {
    if path.directory? {
      Option.Some(Repository { @path = path })
    } else {
      Option.None
    }
  }

  fn tag_names -> Result[iter.Stream[String], Error] {
    run('tag', []).map fn (out) { out.split("\n") }
  }

  # TODO: coalesce the read errors into a single message, instead of propagating
  # whatever message the underlying implementation produces, because that's
  # probably something super cryptic like "broken pipe".
  fn run(command: String, arguments: Array[String]) -> Result[String, Error] {
    let cmd = Command.new('git')

    cmd.argument(command)
    cmd.arguments(arguments)
    cmd.stdin(Stream.Null)
    cmd.stderr(Stream.Piped)
    cmd.stdout(Stream.Piped)

    # TODO: is it really needed to include "git blabla failed: ..." in the
    # message, opposed to just the raw message (or a custom one)? If the user
    # calls `Repository.tags` and it fails with "git tag failed: ..." that's not
    # helpful and even redundant.
    #
    # case: SpawnError
    let child =
      try cmd.spawn.map_error fn (e) { Error.new(command, e.to_string) }

    let out = ByteArray.new
    let stdout = child.stdout
    let stderr = child.stderr

    # case: WaitError
    let status =
      try child.wait.map_error fn (e) { Error.new(command, e.to_string) }

    # case: OutputError/ReadError
    try stdout
      .read_all(out)
      .map_error fn (e) { Error.new(command, e.to_string) }

    if status.success? {
      Result.Ok(out.into_string)
    } else {
      out.clear
      # case: OutputError/ReadError
      try stderr
        .read_all(out)
        .map_error fn (e) { Error.new(command, e.to_string) }

      Result.Error(Error.new(command, out.into_string))
    }
  }
}
