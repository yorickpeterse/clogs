# Types and methods for working with Git repositories.
import std.fs.path.Path
import std.io
import std.iter
import std.string.ToString
import std.sys.(Command, Stream)

# An error produced when running Git commands.
class enum Error {
  # The Git command failed to run, such as due to it not existing, or a lack of
  # permissions.
  case InvalidCommand(io.Error)

  # The output from STDOUT or STDERR couldn't be read.
  case InvalidRead(io.Error)

  # The command ran, but exited with a non-zero exit status.
  case InvalidExit(Int, String)
}

impl ToString for Error {
  fn pub to_string -> String {
    match self {
      case InvalidCommand(e) -> "the Git command failed to run: {e}"
      case InvalidRead(e) -> "the STDOUT or STDERR output couldn't be read: {e}"
      case InvalidExit(c, e) -> "the Git command exited with status {c}: {e}"
    }
  }
}

class Repository {
  let @path: Path

  fn static new(path: Path) -> Option[Repository] {
    if path.directory? {
      Option.Some(Repository { @path = path })
    } else {
      Option.None
    }
  }

  fn tag_names -> Result[iter.Stream[String], Error] {
    run('tag', []).map fn (out) { out.split("\n") }
  }

  fn run(command: String, arguments: Array[String]) -> Result[String, Error] {
    let cmd = Command.new('git')

    cmd.argument(command)
    cmd.arguments(arguments)
    cmd.stdin(Stream.Null)
    cmd.stderr(Stream.Piped)
    cmd.stdout(Stream.Piped)

    let child = try cmd.spawn.map_error fn (e) { Error.InvalidCommand(e) }
    let out = ByteArray.new
    let stdout = child.stdout
    let stderr = child.stderr
    let status = try child.wait.map_error fn (e) { Error.InvalidCommand(e) }

    try stdout.read_all(out).map_error fn (e) { Error.InvalidRead(e) }

    if status.success? {
      Result.Ok(out.into_string)
    } else {
      out.clear
      try stderr.read_all(out).map_error fn (e) { Error.InvalidRead(e) }

      Result.Error(Error.InvalidExit(status.to_int, out.into_string))
    }
  }
}
